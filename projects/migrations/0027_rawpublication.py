# Generated by Django 4.2.20 on 2025-12-10 16:21

from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone

from projects.user_publication.deduplicate import get_originals_for_duplicate_pub


def migrate_sources_and_duplicates(apps, schema_editor):
    Publication = apps.get_model("projects", "Publication")
    PublicationSource = apps.get_model("projects", "PublicationSource")
    PublicationDuplicate = apps.get_model("projects", "PublicationDuplicate")
    RawPublication = apps.get_model("projects", "RawPublication")

    def resolve_canonical(pub):
        # Not a duplicate → canonical is itself
        if pub.status != "DUPLICATE":
            return pub

        # 1. Try PublicationDuplicate
        dup_rel = PublicationDuplicate.objects.filter(duplicate_id=pub.id).first()
        if dup_rel:
            return dup_rel.original

        # 2. Try the external helper
        originals = [
            o for o in get_originals_for_duplicate_pub(pub)
            if o.status == "APPROVED"
        ]

        if len(originals) > 1:
            # Migrations cannot prompt user → force fix
            raise RuntimeError(
                f"Publication {pub.id} has multiple canonical originals: "
                f"{[o.id for o in originals]}"
            )

        if len(originals) == 1:
            return Publication.objects.get(id=originals[0].id)

        # 3. No mapping → treat as self
        return pub


    def create_raw(pub, canonical_pub, source_name, **source_fields):
        RawPublication.objects.create(
            # Source metadata
            publication=canonical_pub,
            name=source_name,
            citation_count=source_fields.get("citation_count", 0),
            entry_created_date=source_fields.get("entry_created_date"),
            is_found_by_algorithm=source_fields.get("is_found_by_algorithm", False),
            cites_chameleon=source_fields.get("cites_chameleon", False),
            acknowledges_chameleon=source_fields.get("acknowledges_chameleon", False),
            approved_with=source_fields.get("approved_with"),
            source_id=source_fields.get("source_id"),

            # Publication metadata
            project=pub.project,
            publication_type=pub.publication_type,
            forum=pub.forum,
            title=pub.title,
            year=pub.year,
            month=pub.month,
            author=pub.author,
            bibtex_source=pub.bibtex_source,
            link=pub.link,
            added_by_username=pub.added_by_username,
            doi=pub.doi,
            checked_for_duplicates=pub.checked_for_duplicates,
        )

    publications = Publication.objects.all()
    for pub in publications:
        canonical_pub = resolve_canonical(pub)
        for src in PublicationSource.objects.filter(publication=pub):
            create_raw(
                pub=pub,
                canonical_pub=canonical_pub,
                source_name=src.name,
                citation_count=src.citation_count,
                entry_created_date=src.entry_created_date,
                is_found_by_algorithm=src.is_found_by_algorithm,
                cites_chameleon=src.cites_chameleon,
                acknowledges_chameleon=src.acknowledges_chameleon,
                approved_with=src.approved_with,
                source_id=src.source_id,
            )



def reverse_noop(apps, schema_editor):
    # You probably don't want to reverse this migration
    pass

class Migration(migrations.Migration):

    dependencies = [
        ('projects', '0026_alter_publication_status'),
    ]

    operations = [
        migrations.CreateModel(
            name='RawPublication',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(choices=[('user_reported', 'User Reported'), ('scopus', 'Scopus'), ('semantic_scholar', 'Semantic scholar'), ('google_scholar', 'Google Scholar')], max_length=30)),
                ('citation_count', models.IntegerField(default=0)),
                ('entry_created_date', models.DateField(default=django.utils.timezone.now)),
                ('is_found_by_algorithm', models.BooleanField(default=False)),
                ('cites_chameleon', models.BooleanField(default=False)),
                ('acknowledges_chameleon', models.BooleanField(default=False)),
                ('approved_with', models.CharField(blank=True, choices=[('publication', 'Publication'), ('justification', 'Justification'), ('email', 'Email')], max_length=30, null=True)),
                ('source_id', models.CharField(blank=True, max_length=1024, null=True)),
                ('publication_type', models.CharField(max_length=50)),
                ('forum', models.CharField(blank=True, max_length=500, null=True)),
                ('title', models.CharField(max_length=500)),
                ('year', models.IntegerField()),
                ('month', models.IntegerField(blank=True, null=True)),
                ('author', models.CharField(max_length=500)),
                ('bibtex_source', models.TextField()),
                ('link', models.CharField(blank=True, max_length=500, null=True)),
                ('added_by_username', models.CharField(max_length=100)),
                ('doi', models.CharField(blank=True, max_length=500, null=True)),
                ('checked_for_duplicates', models.BooleanField(default=False)),
                ('project', models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='projects.project')),
                ('publication', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='raw_sources', to='projects.publication')),
            ],
        ),
        migrations.RunPython(migrate_sources_and_duplicates, reverse_noop),
    ]
